'''
1004. 最大连续1的个数 III
给定一个由若干 0 和 1 组成的数组 A，我们最多可以将 K 个值从 0 变成 1 。
返回仅包含 1 的最长（连续）子数组的长度。
示例 1：
输入：A = [1,1,1,0,0,0,1,1,1,1,0], K = 2
输出：6
解释：
[1,1,1,0,0,1,1,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 6。
示例 2：
输入：A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3
输出：10
解释：
[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 10。
'''

'''
滑动窗口法
题意转换。把「最多可以把K个0变成1，求仅包含1的最长子数组的长度」转换为「找出一个最长的子数组，该子数组内最多允许有K个0」。
代码思路：
使用left和right两个指针，分别指向滑动窗口的左右边界。
right主动右移：right指针每次移动一步。当 A[right]为0，说明滑动窗口内增加了一个0；
left被动右移：判断此时窗口内0的个数，如果超过了K，则left指针被迫右移，直至窗口内的0的个数小于等于K为止。
滑动窗口长度的最大值就是所求。
'''
class Solution:
    def longestOnes(self, A: List[int], K: int) -> int:
        zero = 0
        max_len = 0
        n = len(A)
        right = 0
        left = 0
        while right < n:
            if A[right] == 0:
                zero += 1
            while zero >K:
                if A[left] == 0:
                    zero -= 1
                left += 1
            max_len = max(max_len,right-left+1)
            right += 1
        return max_len
'''
复杂度分析：
时间复杂度：O(N)，因为每个元素只遍历了一次。
空间复杂度：O(1)，因为使用了常数个空间。
'''